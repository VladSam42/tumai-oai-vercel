import subprocess
import sys
import os
from fastapi import FastAPI, HTTPException, Depends, Body, BackgroundTasks
from contextlib import asynccontextmanager
from app.models import Task, ChatMessage, ReplyResponse, ReplyRequest, SessionInfo, TrainingRequest
from app.services.session_manager import SessionManager, TASKS
from app.services.log_vis import LogVisService
from app.routes.dependencies.security import validate_teacher_reply
from app.agents.teacher_agent import TeacherAgent
from app.config import DEFAULT_MODEL, FASTAPI_URL as DEFAULT_TEACHER_URL
from app.agents.prompts.prompt_factory import get_prompt

app = FastAPI()
session_manager = SessionManager()
log_vis_service = LogVisService()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage LogVisService connection during app lifespan."""
    print("Application startup: Connecting LogVisService...")
    await log_vis_service.connect(TASKS)

    # Initialize the teacher agent at startup
    yield
    print("Application shutdown: Disconnecting LogVisService...")
    await log_vis_service.disconnect()


# Pass the lifespan manager to the FastAPI app
app = FastAPI(lifespan=lifespan)


async def get_start_session(task: Task, session_id_arg: int | None = None) -> ReplyResponse:
    """
    Initiates the session. Caches data.
    Uses provided session_id if available.
    Returns a history with the first message generated by the TeacherAgent.
    """
    # Use provided session_id or let manager generate one
    session = session_manager.init_session(task, session_id=session_id_arg)
    session_id = session["session_id"] # Get the actual session_id used (provided or generated)

    await log_vis_service.publish_log(
        session_id,
        {"event": "session_init", "task_id": task.id, "task_title": task.title},
    )

    teacher_agent = TeacherAgent()
    await log_vis_service.publish_log(
        session_id, {"event": "agent_start", "agent": "TeacherAgent", "method": "start_session"}
    )

    scenario, diagnosis, first_response = teacher_agent.start_session(task)
    await log_vis_service.publish_log(
        session_id,
        {
            "event": "agent_end",
            "agent": "TeacherAgent",
            "method": "start_session",
            "output_type": "scenario_diagnosis_response",
            "diagnosis_preview": diagnosis[:100] + "..." if diagnosis else "N/A"
        },
    )

    history = [
        ChatMessage(role="teacher", content=first_response),
    ]
    # Log the initial teacher message
    await log_vis_service.publish_log(
        session_id,
        {"event": "chat_message", "role": "teacher", "content": first_response}
    )

    session["scenario"] = scenario
    session["diagnosis"] = diagnosis
    session["history"] = history
    session_manager.dump_session(session)
    await log_vis_service.publish_log(
        session_id, {"event": "session_saved", "history_length": len(history)}
    )

    return ReplyResponse(
        session_id=session["session_id"],
        history=history,
        is_end=False,
    )


def get_task_by_id(task_id: int) -> Task | None:
    """
    Queries a task by a given id.
    """
    for task in TASKS:
        if task.id == task_id:
            return task
    return None


async def _eval_reply(reply_request: ReplyRequest) -> ReplyResponse:
    """
    Evaluates the response of the student, appends a new message.
    """
    session_id = reply_request.session_id
    await log_vis_service.publish_log(
        session_id,
        {"event": "eval_reply_start", "history_length": len(reply_request.history)},
    )
    
    student_message = reply_request.history[-1]
    await log_vis_service.publish_log(
        session_id,
        {"event": "chat_message", "role": student_message.role, "content": student_message.content}
    )

    session = session_manager.load_session(reply_request.session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found.")

    teacher_agent = TeacherAgent()
    scenario = session.get("scenario", "")
    diagnosis = session.get("diagnosis", "")

    score, is_end, feedback = teacher_agent.eval_reply(
        reply=student_message.content,
        scenario=scenario,
        diagnosis=diagnosis,
        conversation_history=reply_request.history[:-1],
    )
    # Log agent eval end
    await log_vis_service.publish_log(
        session_id,
        {
            "event": "agent_end",
            "agent": "TeacherAgent",
            "method": "eval_reply",
            "score": score,
            "is_end": is_end,
            "feedback_preview": feedback[:100] + "..." if feedback else "N/A"
        },
    )

    # Log response generation stages
    await log_vis_service.publish_log(
        session_id, {"event": "teacher_response_generation_start"}
    )
    prompt_response = get_prompt(
        "teacher/gen_response",
        {
            "scenario": scenario,
            "conversation_history": "\n".join(
                [f"{msg.role}: {msg.content}" for msg in reply_request.history]
            ),
        },
    )
    await log_vis_service.publish_log(
        session_id, {"event": "prompt_generated", "prompt_type": "teacher/gen_response"}
    )
    await log_vis_service.publish_log(
        session_id, {"event": "openai_call_start", "model": DEFAULT_MODEL}
    )
    gen_response_response = teacher_agent.openai_client.chat.completions.create(
        model=DEFAULT_MODEL,
        messages=[{"role": "user", "content": prompt_response}],
        temperature=0.7,
    )
    teacher_response = gen_response_response.choices[0].message.content
    await log_vis_service.publish_log(
        session_id, {"event": "openai_call_end", "response_length": len(teacher_response or "")}
    )

    # Add feedback if session ended
    if is_end:
        teacher_response += f"\n\n**Session Summary**\nYour final score: {score:.2f}/1.0\n\n**Feedback**:\n{feedback}"
        await log_vis_service.publish_log(
            session_id, {"event": "feedback_added_to_response"}
        )

    # Log outgoing teacher message
    if teacher_response:
        await log_vis_service.publish_log(
            session_id,
            {"event": "chat_message", "role": "teacher", "content": teacher_response}
        )
        
    # Append teacher response to history FOR THE API RESPONSE
    reply_request.history.append(
        ChatMessage(role="teacher", content=teacher_response)
    )

    # Update session file history
    session["history"] = [msg.model_dump() for msg in reply_request.history]
    session_manager.dump_session(session)
    await log_vis_service.publish_log(
        session_id,
        {"event": "session_saved", "history_length": len(reply_request.history)},
    )

    # TODO@zeynepyorulmaz: Remove temporary override once eval_reply works correctly
    score, is_end = 0.8, False 
    # Log scoring/end decision (using values from eval_reply)
    # await log_vis_service.publish_log(
    #     session_id, {"event": "scoring_end", "score": score, "is_end": is_end}
    # )

    if is_end:
        session_manager.update_session_status(session_id, "finished")
        await log_vis_service.publish_log(
            session_id, {"event": "session_status_updated", "status": "finished"}
        )

    return ReplyResponse(
        session_id=reply_request.session_id,
        history=reply_request.history, # Return updated history
        score=score, # Return score from eval_reply
        is_end=is_end, # Return is_end from eval_reply
    )

# --- Helper Functions ---
def run_training_script(task_id: int, teacher_url: str, max_turns: int, session_id: int | None = None):
    """Executes the training script in a background subprocess."""
    script_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'scripts', 'training.py'))
    command = [
        sys.executable, # Use the same python interpreter that runs FastAPI
        script_path,
        '--task_id', str(task_id),
        '--max_turns', str(max_turns),
        '--url', teacher_url
    ]
    # Add session_id argument if provided
    if session_id is not None:
        command.extend(['--session_id', str(session_id)])
        
    print(f"Running training script in background with command: {' '.join(command)}")
    try:
        # Run in background, do not capture output (it will print to FastAPI console)
        process = subprocess.Popen(command, text=True)
        print(f"Started training process with PID: {process.pid}. It will run in the background.")
        # We don't wait for completion here (process.communicate() removed)
    except FileNotFoundError:
        print(f"Error: Training script not found at {script_path}")
        # Consider logging this error more formally
    except Exception as e:
        print(f"Failed to start training script subprocess: {e}")
        # Consider logging this error more formally


# --- API Endpoints ---
@app.get("/tasks", response_model=list[Task])
def get_tasks():
    return TASKS


@app.get("/sessions", response_model=list[SessionInfo])
def get_sessions():
    """
    Returns a list of currently active session IDs and their status.
    """
    sessions = session_manager.list_sessions()
    return sessions


@app.post("/start_session", response_model=ReplyResponse)
async def start_session(task_id: int, session_id: int | None = None) -> ReplyResponse:
    """Starts a new session, potentially using a provided session ID."""
    task = get_task_by_id(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found.")
    # Pass the optional session_id to the helper function
    return await get_start_session(task, session_id_arg=session_id)


@app.post("/eval_reply", response_model=ReplyResponse)
async def eval_reply(
    request: ReplyRequest = Depends(validate_teacher_reply),
) -> ReplyResponse:
    return await _eval_reply(request)


@app.post("/run_training")
async def run_training(request: TrainingRequest, background_tasks: BackgroundTasks):
    """
    Starts the training simulation script as a background task.
    Accepts an optional session_id to be used by the script.
    """
    # Validate task_id
    if not get_task_by_id(request.task_id):
        raise HTTPException(status_code=404, detail=f"Task with ID {request.task_id} not found.")

    # Use provided URL or default from config
    effective_teacher_url = request.teacher_url or DEFAULT_TEACHER_URL
    provided_session_id = request.session_id # Get optional session ID from request

    # Add the script execution to background tasks
    background_tasks.add_task(
        run_training_script,
        request.task_id,
        effective_teacher_url,
        request.max_turns,
        provided_session_id # Pass the session_id to the helper
    )

    response_message = f"Training simulation for task {request.task_id} added to background queue."
    if provided_session_id is not None:
        response_message += f" Requested Session ID: {provided_session_id}."
        # Note: The actual session creation happens in the background script.
        # If the ID is invalid or conflicts, warnings will be logged by the script/session manager.

    return {"message": response_message}


@app.delete("/delete_session/{session_id}")
async def delete_session(session_id: int):
    """
    Deletes the session with the given ID.
    """
    sm = SessionManager()
    is_ok, msg = sm.delete_session(session_id)
    return {"success": is_ok, "message": msg}
